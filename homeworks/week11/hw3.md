## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

- 最值觀的方法→加密可以解密，雜湊不能返回原來的輸入值
- 加密是一對一，雜湊是多對有限的一，並且雜湊有機會產生「碰撞」
- 話說我一個多月前老師的直播上也問過相同的蠢問題....現在想想果然很瞎
- 因為密碼直接存在資料庫上，那麼只要被盜走就可以取得使用者使用的密碼，而這個密碼很有可能跟其他服務或系統所共用，因此會發生昨天A網站爆出資安個資被竊取的問題，今天就發生B網站被人惡意登入做壞事
- 解決方法是網站、系統所儲存的密碼是經過雜湊的密碼，這樣被盜走也很難解開，除非對方也是先用相同雜湊方式做了輸入輸出表
- 然而畢竟一般大部分人的的密碼都不會太長，因此透過暴力破解，事先把所有的密碼可能的MD5都先算出來，之後只要入侵伺服器取得密碼欄位儲存的雜湊值，再透過查表就可以推導出使用者最原本的密碼了
- 針對這種暴力破解的應對方式，就是「加鹽」Salting，也就是針對使用者的密碼再加亂數，例如原本使用者密碼是abc，在儲存密碼時針對「abc」這個密碼加鹽成「abcwfj2!o9ie@#」，然後再轉換成SHA256版本，增加破解難度
- 簡單來講，加鹽就是幫使用者增加密碼的複雜度，預防被破解

## `include`、`require`、`include_once`、`require_once` 的差別

- 看到這題我還真的愣住了，因為實在沒什麼印象....所以找了以下的資料來源

[簡單談談PHP中的include、include_once、require以及require_once語句](https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/213553/)

### require_once()

- 用來引用檔案時的匯入指令，使用`require_once(檔案路徑);`即可，該指令會把引入的檔案內已經宣告的變數一起引用進來，可以直接使用

### require()

- 跟`require_once()`的不同之處在於，儘管檔案已經被載入了，但只要發現是`require`指令，就會強制重新再載入一次，也因此會發生相同的凾式或變數被重新載入而產生衝突，解決方式就是使用有`_once()`的`require_once()`，因為當監測到檔案已經載入時就不會再次載入

### include()

- 跟`require()`的差別在於，儘管沒有找到要匯入的檔案，雖然會報錯，但仍然會繼續執行，但這樣很有可能會產生預期外的錯誤，例如明明沒有正確載入伺服器的連線檔案，等於取得不到伺服器回傳的SQL資料，卻還是執行了網頁後續內容而產生錯誤，因此建議還是使用`require_once()`就好

### include_once()

- 跟require_once()還有require()的情況相同，差別在於是否會重複載入檔案內容

![https://i.imgur.com/4d9L996.png](https://i.imgur.com/4d9L996.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c60436a-96f1-42d9-a880-b326f7d94a53/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c60436a-96f1-42d9-a880-b326f7d94a53/Untitled.png)

## 請說明 SQL Injection 的攻擊原理以及防範方法

- SQL注入攻擊，顧名思義將合法正常的SQL指令，惡意修改成駭客所期望的指令，這情況大多發生在用字串拼接的SQL語法，例如拼接語法為`Select * from table where account = 'var1' and password = 'var2'`，其中 `var1` 跟 `var2` 都是字串拼接用的變數，整句代表找尋符合帳號密碼都對的該筆資料
- 上面只要變數 var1 的內容是 `帳號' or 1=1#`，SQL指令就會變成 改寫成`Select * from table where account = '帳號' or 1=1 # and password = var2`，就可以在沒有密碼的情況下查詢到該筆帳號的資料
- 解決方式是避免將使用者輸入的內容當成指令來執行，使用Prepared Statement參數化查詢，將輸入作為「純文字」來處理，例如MySQL可以使用內建指令`prepare()`、`bind_param()`、`execute()`來處理

## 請說明 XSS 的攻擊原理以及防範方法

- 與上面的SQL注入攻擊有點類似，都是使用者惡意的輸入含有程式碼意涵的內容，導致執行了JavaScript指令，正常來講使用者輸入的內容都應該看作純文字而不應具備執行程式碼的功能，
- 例如在網頁顯示頁面上，沒有阻擋XSS攻擊的話，只要使用者輸入`<script>alert('GG')</script>`，那麼不管任何人看到該網頁都會跳出一個GG的告警視窗，嚴重會導致瀏覽器將其他使用者的Cookie或其他重要資料傳到駭客的手中
- 解決方式同樣是將輸入內容轉換成純「文字」，其中`escapeHtml()`是JavaScript中自定義的函式，換句話說可以把程式語法轉換成純文字，可以抵擋XSS攻擊，因此使用時機是用在「前台顯示上」
- 而`encodeURIComponent()`屬於JavaScript內建的函式，用於在用QueryString傳遞資料時 (不管是作為GET的網址傳遞或是POAST傳遞) 避免`?`、`=`、`&`這種文字被誤認成QueryString的指令，跟上面`escapeHtml()`有點不太一樣，偏向「前端傳向後端處裡時使用」

## 請說明 CSRF 的攻擊原理以及防範方法

- 全名為Cross Site Request Forgery，跨站請求偽造
- 概念是偽造使用者的Request向其他地方發出請求
- 原理是惡意網站要求使用者點擊按鈕，但該按鈕會發送指令給目標服務，假借是使用者的身分向目標網站提出服務請求，儘管使用者並無此意，但「身分卻遭冒用了」
- 而比較靠北的是網頁放入微小的圖片元素`img`，圖片來源則指項目標服務，同樣可以在使用者不知情的情況下，在駭客的網站端，假借使用者身分發出請求
- 以下是題外話，這讓我想到五年前跟著大學同學去九州的玩，第三天很哭腰的沒有好旅館睡，大家擠在一個小房間過夜，我因為太累手機抓在手上就不小心睡著了。第二天醒來，發現手機裡的FB竟然發了一堆吃屎文，欸不對呀?  我手機明明有上指紋鎖為什麼還能被破解開來?結果原來是那群混蛋們趁我睡覺的時候，抓著我的手指去解開手機的指紋鎖
- 上面那低能的情況，就類似駭客 (低能同學) 偽造使用者的請求 (抓著我的手指解鎖手機)，向銀行進行網頁轉帳 (在FB上PO吃屎文)

- 抵擋方式分三種，第一種是瀏覽器上的服務用完記得登出停用，另外還有別點選來路不明的網頁
- 第二種則是伺服器端針對請求內容檢查「請求來源」在標頭欄位中，先查看`Origin`值是否跟目前domain相同，如果沒有`Origin`則看`Referer`
- 在更好一點的就是針對敏感的服務增加二次驗證，例如簡訊、信箱驗證碼認證等
- 另外可以仿照先前Session的機制，額外在機敏請求中置入隱藏的Token，並且該Token是存在伺服器端，只要使用者發出表單請求，就會檢查該表單隱藏的Token是否跟伺服器端相同，如果相同就代表是本人而不是釣魚網站發的
- 而如果不將Token存在伺服器端，可以設定要求使用者將Token寫入Cookie中，並且在Form表單內同時也洗入與Cookie相同的Token，這樣只要驗證兩者Token是否相同即可

- 而第三種是瀏覽器端，可以針對Cookie設定same site功能，意思就是只有在相同站點的情況下才把該筆Cookie帶上去，而其中same site的Lax模式，可以針對html元素的<a>、<link>、get請求這種放寬權限帶上Cookie，但要留意Lax模式無法阻擋Get的CSRF