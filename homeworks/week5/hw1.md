## 前四週心得與解題心得

## LOIJ題目

- 先來談談第一次複習週的作業吧，上面提到說把LIOJ沒做過的題目都做一遍。因為先前在學習第二第三週時已連同把LIOJ的題目都也寫過一遍，所以剩下就是比較難的52、53兩題

![https://i.imgur.com/rLjo9xL.png](https://i.imgur.com/rLjo9xL.png)

- 關於第51題的小偷問題，其實我思考了好久，本來想說用很多個for迴圈包起來做好每個排列組合後來比大小，但他的N是20個，總感覺會變成N的20次方那麼多，想想用遞迴....又不曉得怎樣個遞迴法比較有結構性的契合到這一題。最後回到最初的原點，思考如果我是一般人的話，我是如何判斷到底怎樣才會划算呢?但最後結果滿感傷的....我是用眼睛看大約哪些比較有可能才去計算，而沒有個很邏輯或系統性的去對物品的價值去判斷，甚至可以說憑感覺去決定要先計算哪個。不過倒是有想說假設針對物品的重量及價值做加權計算呢?例如A物品每一單位重量換算成金錢會是多少，再來比大小以及不要超過重量上限。不過這個發想最後還是胎死腹中，完全不曉得從何下手。
- 花太多時間在這題上面了，最後放棄選擇上網找「背包問題」，結果查到組合數學時，看到WIKI裡面有這麼一段

西元前6世紀的古印度外科醫生妙聞已經指出可以由6個相異的味道組合出63種相異的結果（每個味道都可以選擇或不選擇，但不能都不選擇，因此有$2^6$ − 1=63種組合

- 既然這樣，那麼全部有20個，扣除都不選的情況，是不是就變成有$2^{20}-1$=1048575，本來想說先把20個依照重量或價值做大小排序，現在好像也不需要了。不過這樣重複計算的事情，應該會用到遞迴才是。
- 在還想不出遞迴之前，根據測試資料的陽春版內容如下，三層for迴圈，對應到三個物品，換句話說用這模式就要寫20個for迴圈了，不用遞迴好像有點母湯-.-

```jsx
function solve(n) {
		const bagLimit = Number(n[0].split(' ')[1]); // 包包可以放多重
    const arrayWeight = []; // 存放物品的重量陣列
    const arrayPrice = []; // 存放物品的價值陣列
    const num = Number(n[0].split(' ')[0]); // 有幾個物品(陣列長度)

    for (let i = 1; i < n.length; i += 1) { // 將物品依照價值高到低排序
        for (let j = 1; j < n.length - i; j += 1) {
            let x = Number(n[j].split(' ')[1]);
            let y = Number(n[j + 1].split(' ')[1]);
            if (x < y) { // 大排到小
                let temp = n[j];
                n[j] = n[j + 1];
                n[j + 1] = temp;
            }
        }
    }
    
    let maxPrice = 0; // 最高價值
    for (let i = 1; i < n.length; i += 1) {
        arrayWeight[i - 1] = Number(n[i].split(' ')[0]);
        arrayPrice[i - 1] = Number(n[i].split(' ')[1]);
    }

    let count = 0;//統計計算次數
    for (let i = 0; i < num; i += 1) { // 第一層
        let weight = arrayWeight[i];
        let temp = arrayPrice[i];
        if (temp > maxPrice) { // 若暫存金額為最大，則設定為最大值
            maxPrice = temp;
        }
        
        for (let x = i + 1; x < num; x += 1) { // 第二層
            if ((weight + arrayWeight[x]) <= bagLimit) { // 當重量不超過上限時，金額加總
                temp += arrayPrice[x];
                weight += arrayWeight[x];
                if (temp > maxPrice) { // 若暫存金額為最大，則設定為最大值
                    maxPrice = temp;
                }
            }
            for (let y = i + x + 1; y < num; y += 1) { // 第三層
                if ((weight + arrayWeight[y]) <= bagLimit) { // 當重量不超過上限時，金額加總
                    temp += arrayPrice[y];
                    weight += arrayWeight[y];
                    if (temp > maxPrice) { // 若暫存金額為最大，則設定為最大值
                        maxPrice = temp;
                    }
                }
            }
        }
    }
    console.log(maxPrice);
}
```

- 看起來好像沒啥問題，所以嘗試寫成遞迴的情況試試

```jsx
function solve(n) {
    const bagLimit = Number(n[0].split(' ')[1]); // 包包可以放多重
    const arrayWeight = []; // 存放物品的重量陣列
    const arrayPrice = []; // 存放物品的價值陣列
    const num = Number(n[0].split(' ')[0]); // 有幾個物品(陣列長度)

    for (let i = 1; i < n.length; i += 1) { // 將物品依照價值高到低排序
        for (let j = 1; j < n.length - i; j += 1) {
            let x = Number(n[j].split(' ')[1]);
            let y = Number(n[j + 1].split(' ')[1]);
            if (x < y) { // 大排到小
                let temp = n[j];
                n[j] = n[j + 1];
                n[j + 1] = temp;
            }
        }
    }
    
    let maxPrice = 0; // 最高價值
    for (let i = 1; i < n.length; i += 1) {
        arrayWeight[i - 1] = Number(n[i].split(' ')[0]);
        arrayPrice[i - 1] = Number(n[i].split(' ')[1]);
    }

    let count = 0;//統計計算次數
    for (let i = 0; i < num; i += 1) { // 第一層
        let weight = arrayWeight[i];
        let temp = arrayPrice[i];
        if (temp > maxPrice) { // 若暫存金額為最大，則設定為最大值
            maxPrice = temp;
        }        
        findPrice(i, weight, temp);
    }
    console.log(maxPrice);

    function findPrice(index, weight, temp) {

        count += 1;
        for (let x = index + 1; x < num; x += 1) { 
            if ((weight + arrayWeight[x]) <= bagLimit) { // 當重量不超過上限時，金額加總
                temp += arrayPrice[x];
                weight += arrayWeight[x];
                if (temp > maxPrice) { // 若暫存金額為最大，則設定為最大值
                    maxPrice = temp;
                }
            }
            if (index < num) {
                findPrice(x, weight, temp);
            }
        }
    }
}
```

- 不過丟進LIOJ裡面也只會告訴你超過時間，最後評估花了太長時間搞這題，拖到後面趕進度的時間，所以決定投降放棄，開始找解答，一連看了三篇果然不太曉得在寫什麼，只知道似乎是列出包包從1到滿的重量，然後依序放入東西後從金額最高的往回推放了什麼東西進去，所以放棄這些的解釋文件

[背包問題（Knapsack Problem）](https://openhome.cc/Gossip/AlgorithmGossip/KnapsackProblem.htm)

[](https://kknews.cc/zh-tw/news/kba3l88.html)

- 接著找尋老師在第三週出的超級挑戰題解答，我必須說看了內容後還是滿頭問號。我寫了落落常沒能成功，老師寫了少少幾行就結束了，並且儘管有了註釋說明，還是不太理解老師那樣子寫的原因，突然覺得自己是不是可能智商不太夠之類的...
- 第二個的走迷宮，看看也決定放棄，這不是我這程度一天內可以解決的，不過查詢了一下，似乎是用廣度搜尋的演算法，將每個可以移動的路徑當作一個節點做路徑切割，最後找出終點在哪裡，但這裡跟我原本想像的二元樹有些不同，因為在地圖上的一個點，除了原本你來的位置之外最多還有三個方向可以走，所以感覺應該會是三元樹才是
- 總之對於還在趕進度的我這兩題都超出目前能力的範圍了先Pass去看其他的，等之後有空了再回頭來瞧瞧

## HTTP GAME

- 這個對我來說感覺滿有趣的，其實早在加入這個課程時就在課程介紹中看過這個遊戲網站了，那時候還搞不太清楚這樣的文字網頁該如何玩，但單純學了第四週的課程，知道Header跟Query String後，這題曉得該怎麼玩了
- 不過雖然曉得Query String怎麼用，但卻鑽牛角尖想嘗試用request函式庫搭配formData的方式將token傳給伺服器端，卻怎麼都沒試成功，詢問後才發現這得要伺服器有支援才行。確實這件事情先前老師也有特別提到類似的事情，在contest-type如果伺服器沒有支援對應的格式，那麼就算內容對了也是會報錯，而這邊也沒提到說Query String可以用formData來傳遞
- 第六題開始要透過驗證機制傳遞參數，關於Base64轉換工具以及Http Basic Authorization參考以下兩個網站

[Base64 編碼 - 將字串轉換為Base64 - ez2o Studio](https://www.ez2o.com/App/Coder/Base64)

[開發者必備知識 - HTTP認證（HTTP Authentication）](https://carsonwah.github.io/http-authentication.html)

- 第八題的部分，似乎丟入查詢的`q=`沒辦法查詢中文字的樣子?所以決定將清單全部抓下來後在本地端搜尋。不過正打算開始做時想到，可能是中文編碼在QueryString上要編碼處理，使用`encodeURIComponent('我')`指令，編碼後變成`%E6%88%91`
- 第九題的IE6，我是查詢這裡介紹User-Agent，裡頭提到IE6可以寫成`MSIE 6.0`

[User-Agent](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Headers/User-Agent)

- 第十題第一次就猜4413，直接2A0B，一整個嚇到0.0，所以很快就猜到9613這個答案了
- 第13題以為只要把語言改成菲律賓就好，卻沒想到竟然真的是看IP來源?當下就想開有在用FLYVPN切去菲律賓了。結果卡了20多分鐘還是不曉得要改哪些標頭，結果搜尋他人闖關的經驗...竟然還真的是掛個代理直接去取得喔?傻眼+1。另外強烈建議題目從菲律賓改成日本或其他知名的國家，菲律賓的代理伺服器好難找，跟解題相比花更多時間在找可以正常使用的菲律賓代理伺服器@@
- 花了快一個小時找菲律賓的代理伺服器，成功解決掉這一題，但總覺得哪裡怪怪的，因為我確實在Header的文件中看到有關於代理的`Forwarded`的指令，在尋找老師詢問後，這才了解其實我最一開始修改標頭的方式也是可行的，只是指令得使用`'X-Forwarded-For': '菲律賓代理IP'`，當初看文件見到第一個參數是Client就以為那應該要填我自己的本地端IP，殊不知這題就是要為造來源端IP，所以填寫菲律賓代理IP才是正解

[Forwarded](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded)

- 第14題本來看了還滿頭問號，有點沒問到點上看不懂題目，翻了下提示後發現原來都跟User-Agent有關，只是這次是要模仿Google瀏覽器，我同樣用下面的這個網站拉到底看到了網路爬蟲這個項目說明，直覺就是這個，丟進去後通關

[User-Agent](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Headers/User-Agent)

- 真的滿喜歡HTTP GAME這個作業的，很像是在玩解謎遊戲，目前最有趣的作業!!!

## Show Time

- 真心覺得有這樣的單元展示滿重要的，對於完全不曉得整體情況的我而言，真的是學了前四週的東西也不曉得究竟可以實際應用到什麼地步，而看完老師的ShowTime後，就會有種「原來是眼界(智商)限制了我的想像」，那個公車查詢系統真的超厲害的，用的幾乎都是老師上課有提到的東西，但你問我能否做到，我是壓根都沒想到可以那樣子做。
- 另外在影片中因為是現場直接寫Code，所以包括老師習慣的寫法跟思維邏輯也都展現了出來，例如老師在寫新東西時，似乎第一個就是想說這東西能不能切分出一個新的Function，如果可以的話先把Function的外部寫好，接著再去內部填寫框架，儘管這樣的寫作方法在課堂中老師有提過兩三次，但因為跟自己平常寫的習慣落差頗大，所以當初並沒有怎麼在意，但現在看起來老師的這種寫Code方式反而還比較人性化一點，並且重點是不會把程式碼搞得跟狗啃依樣東一塊西一塊
- 在兩支影片中，老師都有用到Call back function這個方式，這東西在第三週有提到，但我翻開筆記，發現老師實際影片用的Call back function跟我自己記錄以為的Call back function落差很大。我以為的是，給定一個函式，裡面傳入的參數都是已經指定好順序的不能更改，你則是在這個函式裡面根據傳入的指定資料做處理。怎麼說呢...聽起來很玄的一件事情@@
- 另外還觀察到一個情況是，老師非常熟悉的運用了字串處理的函式，這些函式都是第二週的內容，雖然曉得歸曉得，但是距離老師那樣運用自如還有段很長的路要走。簡單來說，曉得但無法靈活運用

## 一路走來的學習心得

- 不得不說，謝謝老師讓我有課可以上!!!!對於年過30還沒一技之長只能吃自己的失業中年仔來說，沒有什麼比能養活自己更重要的事情了，有了前公司的雜工經驗，才看清自己應該要好好學點東西，將來不用看人臉色跟要飯似的。不吃軟飯，有付出，有收穫，有成就感，這樣才活著長久走下去
- 目前進度第五周，時間來到8/10，進度整整慢了別人快一個月的時間，真的是超級恐慌!!!!不過確實這段時間學起來非常扎實，我最擔心的基礎部分都有從0開始一步一腳印補起來。
- 第一週是讓我最震撼的，本以為第一週都會教些很簡單的東西，沒想到首先上陣的就是每次被念「身為工程師卻不會用，到底在搞三小」的Git，讓我對這堂課程大開眼界
- 第二第三週回到程式碼基本面，把一些以前似懂非懂的地方補起來，不過感覺內容真的非常多，我有些底子全部都好好看完不摸魚作筆記也是花了非常多的時間，就罔論真新手遇到這些第一次接觸的東西會多手忙腳亂了，特別是一些練習題是要花時間投入進去接觸才會有所成長的，這些並非走馬看花的東西時間變得至關重要。回頭想想也許老師可以把第二第三週再切分出二、三、四週，讓學生更有餘裕學習消化這些東西
- 我當初為了假裝有在進度內而在當週把題目做完，說實在第二週課程題目對我而言難度沒有很高，但過一陣子回頭想想，我為了做表面功夫，光看影片標題就覺得這個對我而言太簡單，而鴨子划水的把這些課程給滑掉了，對我而言真的有確切吸收到知識嗎?這答案是否定的，所以在第二週幹蠢事後，決定從頭開始把每段影片看完並且實際動手操作完，果真很多細節或是小技巧都隱藏在老師的影片當中，雖然因此讓進度慢了許多，但很慶幸我做了這樣的決定，扎扎實實的學習每週的課程
- 第四周則是讓我眼睛為之一亮的一週，姑且不討論原先曉得的IP、DNS等網路MIS面的問題，對於第一次接觸Request的我而言真的是各種驚喜，特別是當老師只用http函式庫就做出簡單的伺服器端後，真的是把我給嚇死了。GET、POST這些東西則是之前有耳聞並且有簡單摸了一點，現在則是真正的把這些東西學起來，這週跟第一週一樣，都是讓自己覺得有飛速成長的一週
- 會放棄嗎?當然不會，因為我已經沒有退路了，所以放棄這個選項是不存在的，但確實追進度的心理壓力還滿大的，像這個周末在寫第五周的題目就搞得心情很不好，因為投入了大量的時間卻沒能搞懂小偷跟走迷宮的題目，既沒成果又延後了趕進度的時間，效率奇差無比=..=

